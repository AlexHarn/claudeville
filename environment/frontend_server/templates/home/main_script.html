{% load static %}

<div id="step" style="display:none">{{step}}</div>
<div id="sim_code" style="display:none">{{sim_code}}</div>
<div id="persona_name_list" style="display:none">{{persona_name_str}}</div>
<div id="persona_init_pos" style="display:none">
	{% for i in persona_init_pos %}
		<span>{{i.0}},{{i.1}},{{i.2}}</span>
	{% endfor %}
</div>

<script type="text/javascript">
	// ###########################################################################
	// PREAMBLE
	// ###########################################################################

	let step = parseInt(document.getElementById('step').innerHTML);
	let sim_code = document.getElementById('sim_code').innerHTML;

	let spans = document.getElementById('persona_init_pos').getElementsByTagName('span');
	let persona_names = {};
	for(var i = 0, l = spans.length; i < l; i++){
		let x = spans[i].innerText.split(",");
		persona_names[x[0]] = [parseInt(x[1]), parseInt(x[2])]
	}

	// Phaser 3.0 global settings - FULL SCREEN RESPONSIVE
	const config = {
	  type: Phaser.AUTO,
	  width: window.innerWidth,
	  height: window.innerHeight,
	  parent: "game-container",
	  pixelArt: true,
	  scale: {
	    mode: Phaser.Scale.RESIZE,
	    autoCenter: Phaser.Scale.CENTER_BOTH
	  },
	  physics: {
	    default: "arcade",
	    arcade: {
	      gravity: { y: 0 }
	    }
	  },
	  scene: {
	    preload: preload,
	    create: create,
	    update: update
	  }
	};

	const game = new Phaser.Game(config);
	let showDebug = false;

	// Camera control state
	let isDragging = false;
	let dragStart = { x: 0, y: 0 };
	let scrollStart = { x: 0, y: 0 };
	let zoomLevel = 1.0;
	const zoomMin = 0.3;
	const zoomMax = 3.0;
	const zoomStep = 0.1;
	let mainCamera = null;
	let mapBounds = { width: 0, height: 0 };

	// Persona related variables
	var spawn_tile_loc = {};
	for (var key in persona_names){
		spawn_tile_loc[key] = persona_names[key];
	}

	var personas = {};
	var pronunciatios = {};
	let anims_direction;
	let pre_anims_direction_dict = {};

	let curr_maze = "the_ville";
	let tile_width = 32;
	let movement_speed = 32;

	// Movement display variables
	let pollInProgress = false;
	let execute_movement = null;
	let execute_count_max = tile_width/movement_speed;
	let execute_count = 0;
	let movement_target = {};

	// ==========================================================================
	// Playback Controls
	// ==========================================================================
	let isPaused = false;
	let isSkipping = false;
	let playbackSpeed = 5;
	let animationDelay = 200;
	let lastAnimationTime = 0;

	// ==========================================================================
	// Simulation Control (Frontend-driven)
	// ==========================================================================
	let isSimulating = false;
	let simulationActive = true;  // Master switch for auto-simulation
	let queuedMovements = 0;      // Steps queued but not yet animated
	let displayedStep = step;     // Step currently being displayed
	let simulatedStep = step;     // Step simulated on backend
	const TARGET_BUFFER = 3;      // Target number of steps to keep buffered ahead
	const BATCH_SIZE = 2;         // Steps to request per batch

	async function requestSimulation(numSteps) {
		if (isSimulating) return;
		isSimulating = true;
		updateSimStatus('Simulating...', true);

		try {
			const response = await fetch("{% url 'api_simulate' %}", {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({ steps: numSteps })
			});
			const result = await response.json();
			if (result.status === 'ok') {
				simulatedStep = result.current_step;
				queuedMovements = result.queued_movements;
			} else if (result.error) {
				console.error('[SIM] Backend error:', result.error);
			}
		} catch (error) {
			console.error('[SIM] Request failed:', error);
		}

		isSimulating = false;
		updateSimStatus('Ready', false);
	}

	function updateSimStatus(text, simulating) {
		const statusEl = document.getElementById('sim-status');
		const textEl = document.getElementById('sim-status-text');
		if (textEl) textEl.textContent = text;
		if (statusEl) {
			if (simulating) {
				statusEl.classList.add('simulating');
			} else {
				statusEl.classList.remove('simulating');
			}
		}
	}

	// ==========================================================================
	// Movement Polling
	// ==========================================================================

	async function pollMovements() {
		try {
			const response = await fetch("{% url 'api_movements' %}");
			const result = await response.json();

			if (result.empty) {
				queuedMovements = 0;  // Backend queue is empty, reset our count
				await new Promise(r => setTimeout(r, 500));
				return { hasMovements: false, hadNewAction: false };
			}

			if (result.error) {
				console.error('[POLL] Error:', result.error);
				await new Promise(r => setTimeout(r, 1000));
				return { hasMovements: false, hadNewAction: false };
			}

			execute_movement = result;
			execute_count = execute_count_max;
			const hadNewAction = result.meta && result.meta.had_new_action;
			return { hasMovements: true, hadNewAction: hadNewAction, movement: result };

		} catch (error) {
			console.error('[POLL] Request failed:', error);
			await new Promise(r => setTimeout(r, 1000));
			return { hasMovements: false, hadNewAction: false };
		}
	}

	// Skip mode just sets a flag - the update() loop handles the rest
	// When skipping: runs at max speed, auto-pauses when LLM action detected
	function startSkipMode() {
		isSkipping = true;
		isPaused = false;  // Unpause to let update() run
		updateButtonStates();
		updateSimStatus('Skipping to next action...', false);
	}

	// Called when we detect an LLM action during skip mode
	function handleSkipActionFound(movement) {
		if (!isSkipping) return;

		const activePersonas = movement.meta?.active_personas || [];
		if (activePersonas.length > 0) {
			// Center on the first active persona
			const personaName = activePersonas[0];
			const personaData = movement.persona[personaName];
			if (personaData && mainCamera) {
				const targetX = personaData.movement[0] * tile_width;
				const targetY = personaData.movement[1] * tile_width;
				mainCamera.pan(targetX, targetY, 300, 'Power2');
				console.log('[SKIP] Centering on active persona:', personaName);
			}
		}

		// Stop skipping and pause
		isSkipping = false;
		isPaused = true;
		updateButtonStates();
		updateSimStatus('Ready', false);
	}

	function getAnimationDelay() {
		// During skip mode, run at max speed (no delay)
		if (isSkipping) return 0;
		return Math.max(10, 400 - (playbackSpeed * 40));
	}

	function animateMovements() {
		if (!execute_movement || execute_count <= 0) {
			return true;
		}

		document.getElementById("game-time-content").innerHTML = execute_movement["meta"]["curr_time"];

		for (let i = 0; i < Object.keys(personas).length; i++) {
			let curr_persona_name = Object.keys(personas)[i];
			let curr_persona = personas[curr_persona_name];
			let curr_pronunciatio = pronunciatios[curr_persona_name];

			if (execute_count == execute_count_max) {
				let curr_x = execute_movement["persona"][curr_persona_name]["movement"][0];
				let curr_y = execute_movement["persona"][curr_persona_name]["movement"][1];
				movement_target[curr_persona_name] = [curr_x * tile_width, curr_y * tile_width];

				let pronunciatio_content = execute_movement["persona"][curr_persona_name]["pronunciatio"];
				let rgx = new RegExp(/(\p{L}{1})\p{L}+/, 'gu');
				let initials = [...curr_persona_name.matchAll(rgx)] || [];
				initials = ((initials.shift()?.[1] || '') + (initials.pop()?.[1] || '')).toUpperCase();
				pronunciatios[curr_persona_name].setText(initials + ": " + pronunciatio_content);

				let curr_persona_name_os = curr_persona_name.replace(/ /g, "_");
				let description_content = execute_movement["persona"][curr_persona_name]["description"];

				document.getElementById("current_action__" + curr_persona_name_os).innerHTML = description_content.split("@")[0];
				document.getElementById("target_address__" + curr_persona_name_os).innerHTML = description_content.split("@")[1];
			}

			if (curr_persona.body.x < movement_target[curr_persona_name][0]) {
				curr_persona.body.x += movement_speed;
				anims_direction = "r";
				pre_anims_direction_dict[curr_persona_name] = "r";
			} else if (curr_persona.body.x > movement_target[curr_persona_name][0]) {
				curr_persona.body.x -= movement_speed;
				anims_direction = "l";
				pre_anims_direction_dict[curr_persona_name] = "l";
			} else if (curr_persona.body.y < movement_target[curr_persona_name][1]) {
				curr_persona.body.y += movement_speed;
				anims_direction = "d";
				pre_anims_direction_dict[curr_persona_name] = "d";
			} else if (curr_persona.body.y > movement_target[curr_persona_name][1]) {
				curr_persona.body.y -= movement_speed;
				anims_direction = "u";
				pre_anims_direction_dict[curr_persona_name] = "u";
			} else {
				anims_direction = "";
			}

			curr_pronunciatio.x = curr_persona.body.x - 6;
			curr_pronunciatio.y = curr_persona.body.y - 42 - 32;

			let animKey = curr_persona.spriteKey || "misa";
			if (anims_direction == "l") {
				curr_persona.anims.play(animKey + "-left-walk", true);
			} else if (anims_direction == "r") {
				curr_persona.anims.play(animKey + "-right-walk", true);
			} else if (anims_direction == "u") {
				curr_persona.anims.play(animKey + "-back-walk", true);
			} else if (anims_direction == "d") {
				curr_persona.anims.play(animKey + "-front-walk", true);
			} else {
				curr_persona.anims.stop();
				if (curr_persona.spriteKey) {
					if (pre_anims_direction_dict[curr_persona_name] == "l") curr_persona.setFrame(4);
					else if (pre_anims_direction_dict[curr_persona_name] == "r") curr_persona.setFrame(7);
					else if (pre_anims_direction_dict[curr_persona_name] == "u") curr_persona.setFrame(10);
					else if (pre_anims_direction_dict[curr_persona_name] == "d") curr_persona.setFrame(1);
				} else {
					if (pre_anims_direction_dict[curr_persona_name] == "l") curr_persona.setTexture("atlas", "misa-left");
					else if (pre_anims_direction_dict[curr_persona_name] == "r") curr_persona.setTexture("atlas", "misa-right");
					else if (pre_anims_direction_dict[curr_persona_name] == "u") curr_persona.setTexture("atlas", "misa-back");
					else if (pre_anims_direction_dict[curr_persona_name] == "d") curr_persona.setTexture("atlas", "misa-front");
				}
			}
		}

		execute_count--;

		if (execute_count <= 0) {
			for (let persona_name in personas) {
				personas[persona_name].body.x = movement_target[persona_name][0];
				personas[persona_name].body.y = movement_target[persona_name][1];
			}
			step = execute_movement["meta"]["step"] + 1;
			return true;
		}

		return false;
	}


	// ###########################################################################
	// ENGINE
	// ###########################################################################

	function preload() {
	  this.load.image("blocks_1", "{% static 'assets/the_ville/visuals/map_assets/blocks/blocks_1.png' %}");
	  this.load.image("walls", "{% static 'assets/the_ville/visuals/map_assets/v1/Room_Builder_32x32.png' %}");
	  this.load.image("interiors_pt1", "{% static 'assets/the_ville/visuals/map_assets/v1/interiors_pt1.png' %}");
	  this.load.image("interiors_pt2", "{% static 'assets/the_ville/visuals/map_assets/v1/interiors_pt2.png' %}");
	  this.load.image("interiors_pt3", "{% static 'assets/the_ville/visuals/map_assets/v1/interiors_pt3.png' %}");
	  this.load.image("interiors_pt4", "{% static 'assets/the_ville/visuals/map_assets/v1/interiors_pt4.png' %}");
	  this.load.image("interiors_pt5", "{% static 'assets/the_ville/visuals/map_assets/v1/interiors_pt5.png' %}");
	  this.load.image("CuteRPG_Field_B", "{% static 'assets/the_ville/visuals/map_assets/cute_rpg_word_VXAce/tilesets/CuteRPG_Field_B.png' %}");
	  this.load.image("CuteRPG_Field_C", "{% static 'assets/the_ville/visuals/map_assets/cute_rpg_word_VXAce/tilesets/CuteRPG_Field_C.png' %}");
	  this.load.image("CuteRPG_Harbor_C", "{% static 'assets/the_ville/visuals/map_assets/cute_rpg_word_VXAce/tilesets/CuteRPG_Harbor_C.png' %}");
	  this.load.image("CuteRPG_Village_B", "{% static 'assets/the_ville/visuals/map_assets/cute_rpg_word_VXAce/tilesets/CuteRPG_Village_B.png' %}");
	  this.load.image("CuteRPG_Forest_B", "{% static 'assets/the_ville/visuals/map_assets/cute_rpg_word_VXAce/tilesets/CuteRPG_Forest_B.png' %}");
	  this.load.image("CuteRPG_Desert_C", "{% static 'assets/the_ville/visuals/map_assets/cute_rpg_word_VXAce/tilesets/CuteRPG_Desert_C.png' %}");
	  this.load.image("CuteRPG_Mountains_B", "{% static 'assets/the_ville/visuals/map_assets/cute_rpg_word_VXAce/tilesets/CuteRPG_Mountains_B.png' %}");
	  this.load.image("CuteRPG_Desert_B", "{% static 'assets/the_ville/visuals/map_assets/cute_rpg_word_VXAce/tilesets/CuteRPG_Desert_B.png' %}");
	  this.load.image("CuteRPG_Forest_C", "{% static 'assets/the_ville/visuals/map_assets/cute_rpg_word_VXAce/tilesets/CuteRPG_Forest_C.png' %}");

	  this.load.tilemapTiledJSON("map", "{% static 'assets/the_ville/visuals/the_ville_jan7.json' %}");

	  this.load.atlas("atlas",
	                  "https://mikewesthad.github.io/phaser-3-tilemap-blog-posts/post-1/assets/atlas/atlas.png",
	                  "https://mikewesthad.github.io/phaser-3-tilemap-blog-posts/post-1/assets/atlas/atlas.json");

	  for (let persona_name in persona_names) {
	    let sprite_key = persona_name.replace(/ /g, "_");
	    this.load.spritesheet(sprite_key,
	      "{% static 'assets/characters/' %}" + sprite_key + ".png",
	      { frameWidth: 32, frameHeight: 32 }
	    );
	  }
	}

	function create() {
	  const map = this.make.tilemap({ key: "map" });

	  const collisions = map.addTilesetImage("blocks", "blocks_1");
	  const walls = map.addTilesetImage("Room_Builder_32x32", "walls");
	  const interiors_pt1 = map.addTilesetImage("interiors_pt1", "interiors_pt1");
	  const interiors_pt2 = map.addTilesetImage("interiors_pt2", "interiors_pt2");
	  const interiors_pt3 = map.addTilesetImage("interiors_pt3", "interiors_pt3");
	  const interiors_pt4 = map.addTilesetImage("interiors_pt4", "interiors_pt4");
	  const interiors_pt5 = map.addTilesetImage("interiors_pt5", "interiors_pt5");
	  const CuteRPG_Field_B = map.addTilesetImage("CuteRPG_Field_B", "CuteRPG_Field_B");
	  const CuteRPG_Field_C = map.addTilesetImage("CuteRPG_Field_C", "CuteRPG_Field_C");
	  const CuteRPG_Harbor_C = map.addTilesetImage("CuteRPG_Harbor_C", "CuteRPG_Harbor_C");
	  const CuteRPG_Village_B = map.addTilesetImage("CuteRPG_Village_B", "CuteRPG_Village_B");
	  const CuteRPG_Forest_B = map.addTilesetImage("CuteRPG_Forest_B", "CuteRPG_Forest_B");
	  const CuteRPG_Desert_C = map.addTilesetImage("CuteRPG_Desert_C", "CuteRPG_Desert_C");
	  const CuteRPG_Mountains_B = map.addTilesetImage("CuteRPG_Mountains_B", "CuteRPG_Mountains_B");
	  const CuteRPG_Desert_B = map.addTilesetImage("CuteRPG_Desert_B", "CuteRPG_Desert_B");
	  const CuteRPG_Forest_C = map.addTilesetImage("CuteRPG_Forest_C", "CuteRPG_Forest_C");

	  let tileset_group_1 = [CuteRPG_Field_B, CuteRPG_Field_C, CuteRPG_Harbor_C, CuteRPG_Village_B,
	  											 CuteRPG_Forest_B, CuteRPG_Desert_C, CuteRPG_Mountains_B, CuteRPG_Desert_B, CuteRPG_Forest_C,
	  											 interiors_pt1, interiors_pt2, interiors_pt3, interiors_pt4, interiors_pt5, walls];

	  const bottomGroundLayer = map.createLayer("Bottom Ground", tileset_group_1, 0, 0);
	  const exteriorGroundLayer = map.createLayer("Exterior Ground", tileset_group_1, 0, 0);
	  const exteriorDecorationL1Layer = map.createLayer("Exterior Decoration L1", tileset_group_1, 0, 0);
	  const exteriorDecorationL2Layer = map.createLayer("Exterior Decoration L2", tileset_group_1, 0, 0);
	  const interiorGroundLayer = map.createLayer("Interior Ground", tileset_group_1, 0, 0);
	  const wallLayer = map.createLayer("Wall", [CuteRPG_Field_C, walls], 0, 0);
	  const interiorFurnitureL1Layer = map.createLayer("Interior Furniture L1", tileset_group_1, 0, 0);
	  const interiorFurnitureL2Layer = map.createLayer("Interior Furniture L2 ", tileset_group_1, 0, 0);
	  const foregroundL1Layer = map.createLayer("Foreground L1", tileset_group_1, 0, 0);
	  const foregroundL2Layer = map.createLayer("Foreground L2", tileset_group_1, 0, 0);
	  foregroundL1Layer.setDepth(2);
	  foregroundL2Layer.setDepth(2);

	  const collisionsLayer = map.createLayer("Collisions", collisions, 0, 0);
	  collisionsLayer.setCollisionByProperty({ collide: true });
	  collisionsLayer.setDepth(-1);

	  // *** SET UP CAMERA - Mouse drag panning ***
	  const camera = this.cameras.main;
	  mainCamera = camera;
	  mapBounds = { width: map.widthInPixels, height: map.heightInPixels };

	  camera.setBounds(0, 0, map.widthInPixels, map.heightInPixels);
	  camera.centerOn(map.widthInPixels / 2, map.heightInPixels / 2);

	  // Mouse drag panning
	  this.input.on('pointerdown', function(pointer) {
	    if (pointer.button === 0) {  // Left mouse button
	      isDragging = true;
	      dragStart.x = pointer.x;
	      dragStart.y = pointer.y;
	      scrollStart.x = camera.scrollX;
	      scrollStart.y = camera.scrollY;
	    }
	  });

	  this.input.on('pointermove', function(pointer) {
	    if (isDragging && pointer.isDown) {
	      const dx = pointer.x - dragStart.x;
	      const dy = pointer.y - dragStart.y;
	      camera.scrollX = scrollStart.x - dx / camera.zoom;
	      camera.scrollY = scrollStart.y - dy / camera.zoom;
	    }
	  });

	  this.input.on('pointerup', function(pointer) {
	    isDragging = false;
	  });

	  // Mouse wheel zoom
	  this.input.on('wheel', function(pointer, gameObjects, deltaX, deltaY, deltaZ) {
	    if (deltaY < 0) {
	      zoomLevel = Math.min(zoomMax, zoomLevel + zoomStep);
	    } else if (deltaY > 0) {
	      zoomLevel = Math.max(zoomMin, zoomLevel - zoomStep);
	    }

	    camera.setZoom(zoomLevel);

	    const zoomIndicator = document.getElementById('zoom-indicator');
	    if (zoomIndicator) {
	      zoomIndicator.textContent = Math.round(zoomLevel * 100) + '%';
	    }
	  });

	  // Handle window resize
	  this.scale.on('resize', function(gameSize) {
	    camera.setViewport(0, 0, gameSize.width, gameSize.height);
	  });

	  // *** SET UP PERSONAS ***
	  const anims = this.anims;

	  for (let i=0; i<Object.keys(spawn_tile_loc).length; i++) {
	    let persona_name = Object.keys(spawn_tile_loc)[i];
	    let sprite_key = persona_name.replace(/ /g, "_");
	    // Use same coordinate system as movement_target in animateMovements()
	    let start_pos = [spawn_tile_loc[persona_name][0] * tile_width,
	                     spawn_tile_loc[persona_name][1] * tile_width];

	    let new_sprite;
	    if (this.textures.exists(sprite_key)) {
	      new_sprite = this.physics.add
	                       .sprite(start_pos[0], start_pos[1], sprite_key, 1)
	                       .setSize(30, 40)
	                       .setOffset(0, 32);

	      anims.create({
	        key: sprite_key + "-front-walk",
	        frames: anims.generateFrameNumbers(sprite_key, { frames: [0, 1, 2, 1] }),
	        frameRate: 4,
	        repeat: -1 });

	      anims.create({
	        key: sprite_key + "-left-walk",
	        frames: anims.generateFrameNumbers(sprite_key, { frames: [3, 4, 5, 4] }),
	        frameRate: 4,
	        repeat: -1 });

	      anims.create({
	        key: sprite_key + "-right-walk",
	        frames: anims.generateFrameNumbers(sprite_key, { frames: [6, 7, 8, 7] }),
	        frameRate: 4,
	        repeat: -1 });

	      anims.create({
	        key: sprite_key + "-back-walk",
	        frames: anims.generateFrameNumbers(sprite_key, { frames: [9, 10, 11, 10] }),
	        frameRate: 4,
	        repeat: -1 });
	    } else {
	      new_sprite = this.physics.add
	                       .sprite(start_pos[0], start_pos[1], "atlas", "misa-front")
	                       .setSize(30, 40)
	                       .setOffset(0, 32);
	    }

	    personas[persona_name] = new_sprite;
	    personas[persona_name].spriteKey = this.textures.exists(sprite_key) ? sprite_key : null;

	    // Initialize movement target to match spawn position
	    movement_target[persona_name] = [start_pos[0], start_pos[1]];

	    pronunciatios[persona_name] = this.add.text(
	                                   new_sprite.body.x - 6,
	                                   new_sprite.body.y - 42 - 32,
	                                   "ðŸ¦", {
	                                   font: "28px monospace",
	                                   fill: "#000000",
	                                   padding: { x: 8, y: 8},
	                                   backgroundColor: "#ffffff",
	                                   border:"solid",
	                                   borderRadius:"10px"}).setDepth(3);
	  }

	  // Fallback misa animations
	  anims.create({
	    key: "misa-left-walk",
	    frames: anims.generateFrameNames("atlas", { prefix: "misa-left-walk.", start: 0, end: 3, zeroPad: 3 }),
	    frameRate: 4,
	    repeat: -1 });

	  anims.create({
	    key: "misa-right-walk",
	    frames: anims.generateFrameNames("atlas", { prefix: "misa-right-walk.", start: 0, end: 3, zeroPad: 3 }),
	    frameRate: 4,
	    repeat: -1 });

	  anims.create({
	    key: "misa-front-walk",
	    frames: anims.generateFrameNames("atlas", { prefix: "misa-front-walk.", start: 0, end: 3, zeroPad: 3 }),
	    frameRate: 4,
	    repeat: -1 });

	  anims.create({
	    key: "misa-back-walk",
	    frames: anims.generateFrameNames("atlas", { prefix: "misa-back-walk.", start: 0, end: 3, zeroPad: 3 }),
	    frameRate: 4,
	    repeat: -1 });
	}


	function update(time, delta) {
	  // Skip if paused or menu open (but NOT if skipping - we want to run fast during skip)
	  if (isPaused || isMenuOpen()) {
	    return;
	  }

	  // Throttle animation speed (getAnimationDelay returns 0 during skip mode)
	  const now = Date.now();
	  if (now - lastAnimationTime < getAnimationDelay()) {
	    return;
	  }
	  lastAnimationTime = now;

	  if (execute_count > 0) {
	    // Animation in progress
	    animateMovements();
	  }
	  else if (!pollInProgress) {
	    // No animation, check for movements and maybe request more simulation
	    pollInProgress = true;
	    pollMovements().then(result => {
	      pollInProgress = false;

	      if (result.hasMovements) {
	        displayedStep++;
	        queuedMovements = Math.max(0, queuedMovements - 1);

	        // Update chat popup with conversation data
	        updateChatPopup(result.movement);

	        // During skip mode, check if this movement had an LLM action
	        if (isSkipping && result.hadNewAction) {
	          handleSkipActionFound(result.movement);
	        }
	      }

	      // Auto-request more simulation if buffer is low and simulation is active
	      if (simulationActive && !isSimulating && queuedMovements <= TARGET_BUFFER) {
	        requestSimulation(BATCH_SIZE);
	      }
	    });
	  }
	}

	function isMenuOpen() {
	  const menu = document.getElementById('menu-overlay');
	  return menu && !menu.classList.contains('hidden');
	}

	// ==========================================================================
	// Control Button Handlers
	// ==========================================================================

	function updateButtonStates() {
		const playBtn = document.getElementById("play_button");
		const pauseBtn = document.getElementById("pause_button");
		const skipBtn = document.getElementById("skip_button");

		// Remove active class from all
		playBtn.classList.remove('active');
		pauseBtn.classList.remove('active');

		if (isSkipping) {
			playBtn.disabled = true;
			pauseBtn.disabled = false;
			skipBtn.disabled = true;
			skipBtn.querySelector('.icon').textContent = 'â³';
		} else if (isPaused) {
			playBtn.disabled = false;
			pauseBtn.disabled = true;
			skipBtn.disabled = false;
			skipBtn.querySelector('.icon').textContent = 'â­';
			pauseBtn.classList.add('active');
		} else {
			playBtn.disabled = true;
			pauseBtn.disabled = false;
			skipBtn.disabled = false;
			skipBtn.querySelector('.icon').textContent = 'â­';
			playBtn.classList.add('active');
		}
	}

	// Play button
	document.getElementById("play_button").addEventListener("click", function() {
		isPaused = false;
		isSkipping = false;
		updateButtonStates();
	});

	// Pause button
	document.getElementById("pause_button").addEventListener("click", function() {
		isPaused = true;
		isSkipping = false;
		updateButtonStates();
	});

	// Skip to next action button
	document.getElementById("skip_button").addEventListener("click", function() {
		if (!isSkipping) {
			startSkipMode();
		}
	});

	// Speed slider
	document.getElementById("speed_slider").addEventListener("input", function(e) {
		playbackSpeed = parseInt(e.target.value);
		document.getElementById("speed_label").textContent = playbackSpeed + "x";
	});

	// ==========================================================================
	// Panel Controls
	// ==========================================================================

	// Toggle panel collapse
	document.getElementById('toggle-panel').addEventListener('click', function() {
		const panel = document.getElementById('persona-panel');
		panel.classList.toggle('collapsed');
	});

	// Click persona card to center camera on that persona
	document.querySelectorAll('.persona-card').forEach(function(card) {
		card.addEventListener('click', function() {
			const personaName = this.getAttribute('data-persona-name');
			if (personaName && personas[personaName] && mainCamera) {
				const personaSprite = personas[personaName];
				mainCamera.pan(personaSprite.body.x, personaSprite.body.y, 500, 'Power2');
			}
		});
	});

	// Initialize button states
	updateButtonStates();

	// ==========================================================================
	// Chat Popup System
	// ==========================================================================

	// Track conversations by group
	let conversations = {};  // {convoId: {participants: Set, lines: [], location: {x, y}}}
	let activeConvoId = null;
	let lastConvoActivity = 0;  // For fade-out timer
	let chatMinimized = false;

	function updateChatPopup(movements) {
		const chatPopup = document.getElementById('chat-popup');
		if (!chatPopup || !movements || !movements.persona) return;

		// Collect all unique chat lines from all personas
		// Key is "speaker:line", value is {speaker, line, location}
		let allLines = new Map();
		let allParticipants = new Set();

		for (const [name, data] of Object.entries(movements.persona)) {
			if (data.chat && data.chat.length > 0) {
				for (const [speaker, line] of data.chat) {
					const key = `${speaker}:${line}`;
					if (!allLines.has(key)) {
						allLines.set(key, {
							speaker,
							line,
							key,
							location: { x: data.movement[0], y: data.movement[1] }
						});
					}
					allParticipants.add(speaker);
				}
			}
		}

		// If we have any chat lines, create a single conversation group
		// (In the future, we could split by location if personas are far apart)
		let activeConvos = {};
		if (allLines.size > 0) {
			const convoId = [...allParticipants].sort().join('_');
			const firstLine = allLines.values().next().value;
			activeConvos[convoId] = {
				participants: allParticipants,
				lines: [...allLines.values()],
				location: firstLine.location
			};
		}

		// Update stored conversations
		conversations = activeConvos;
		const convoIds = Object.keys(conversations);

		if (convoIds.length === 0) {
			// Start fade timer if no activity
			if (Date.now() - lastConvoActivity > 5000) {
				chatPopup.classList.add('hidden');
			}
			return;
		}

		lastConvoActivity = Date.now();
		chatPopup.classList.remove('hidden');

		// Auto-select closest conversation to camera if none selected or current is gone
		if (!activeConvoId || !conversations[activeConvoId]) {
			activeConvoId = findClosestConversation();
		}

		// Update tabs
		updateConversationTabs(convoIds);

		// Update messages for active conversation (if not minimized)
		if (!chatMinimized) {
			updateConversationMessages(activeConvoId);
		}
	}

	function findClosestConversation() {
		if (!mainCamera) return Object.keys(conversations)[0] || null;

		// Get camera center position
		const camX = mainCamera.scrollX + mainCamera.width / 2;
		const camY = mainCamera.scrollY + mainCamera.height / 2;

		let closest = null;
		let minDist = Infinity;

		for (const [convoId, convo] of Object.entries(conversations)) {
			const dx = convo.location.x * tile_width - camX;
			const dy = convo.location.y * tile_width - camY;
			const dist = dx * dx + dy * dy;
			if (dist < minDist) {
				minDist = dist;
				closest = convoId;
			}
		}
		return closest;
	}

	function getInitials(name) {
		// Extract initials from a name (e.g., "Maria Lopez" -> "ML")
		const rgx = new RegExp(/(\p{L}{1})\p{L}+/, 'gu');
		const matches = [...name.matchAll(rgx)] || [];
		return ((matches.shift()?.[1] || '') + (matches.pop()?.[1] || '')).toUpperCase();
	}

	function updateConversationTabs(convoIds) {
		const chatTabs = document.getElementById('chat-tabs');
		if (!chatTabs) return;
		chatTabs.innerHTML = '';

		for (const convoId of convoIds) {
			const convo = conversations[convoId];
			const tab = document.createElement('button');
			tab.className = 'chat-tab' + (convoId === activeConvoId ? ' active' : '');
			// Show initials of first two participants
			const participantInitials = [...convo.participants].slice(0, 2).map(getInitials);
			tab.textContent = participantInitials.join(' & ');
			if (convo.participants.size > 2) {
				tab.textContent += ` +${convo.participants.size - 2}`;
			}
			// Add tooltip with full names
			tab.title = [...convo.participants].join(', ');
			tab.onclick = () => {
				activeConvoId = convoId;
				// Pan camera to conversation location
				if (mainCamera) {
					mainCamera.pan(
						convo.location.x * tile_width,
						convo.location.y * tile_width,
						500, 'Power2'
					);
				}
				updateConversationTabs(convoIds);
				updateConversationMessages(convoId);
			};
			chatTabs.appendChild(tab);
		}
	}

	function updateConversationMessages(convoId) {
		const chatMessages = document.getElementById('chat-messages');
		if (!chatMessages) return;

		const convo = conversations[convoId];
		if (!convo) {
			chatMessages.innerHTML = '<p class="chat-empty">No active conversation</p>';
			return;
		}

		chatMessages.innerHTML = '';
		for (const { speaker, line } of convo.lines) {
			const bubble = document.createElement('div');
			bubble.className = 'chat-bubble';
			bubble.innerHTML = `
				<span class="speaker">${speaker}</span>
				<span class="message">${line}</span>
			`;
			chatMessages.appendChild(bubble);
		}
		chatMessages.scrollTop = chatMessages.scrollHeight;
	}

	// Chat minimize button
	document.getElementById('chat-minimize').addEventListener('click', function() {
		const chatPopup = document.getElementById('chat-popup');
		chatMinimized = !chatMinimized;
		if (chatMinimized) {
			chatPopup.classList.add('minimized');
			this.textContent = '+';
		} else {
			chatPopup.classList.remove('minimized');
			this.textContent = 'âˆ’';
			// Refresh messages when expanding
			if (activeConvoId) {
				updateConversationMessages(activeConvoId);
			}
		}
	});

	// ==========================================================================
	// Menu System (ESC key)
	// ==========================================================================

	function toggleMenu() {
		const menu = document.getElementById('menu-overlay');
		if (menu.classList.contains('hidden')) {
			openMenu();
		} else {
			closeMenu();
		}
	}

	function openMenu() {
		const menu = document.getElementById('menu-overlay');
		menu.classList.remove('hidden');

		// Update current sim info
		document.getElementById('menu-sim-info').textContent =
			`${sim_code} - Step ${displayedStep}`;

		// Load saves list
		loadSavesList();
	}

	function closeMenu() {
		const menu = document.getElementById('menu-overlay');
		menu.classList.add('hidden');
	}

	async function loadSavesList() {
		const savesList = document.getElementById('saves-list');
		savesList.innerHTML = '<p class="saves-loading">Loading...</p>';

		try {
			const response = await fetch("{% url 'api_saves' %}");
			const result = await response.json();

			if (result.saves && result.saves.length > 0) {
				savesList.innerHTML = result.saves.map(save => `
					<div class="save-item ${save.sim_code === sim_code ? 'current' : ''}"
						 data-sim-code="${save.sim_code}">
						<div>
							<div class="save-name">${save.sim_code}</div>
							<div class="save-info">Step ${save.step} - ${save.personas.length} personas</div>
						</div>
						<div class="save-info">${save.curr_time}</div>
					</div>
				`).join('');

				// Add click handlers
				savesList.querySelectorAll('.save-item').forEach(item => {
					item.addEventListener('click', function() {
						const saveCode = this.getAttribute('data-sim-code');
						if (saveCode !== sim_code) {
							// Would need page reload to load different sim
							alert('Loading different simulations requires restarting the backend with that save.');
						}
					});
				});
			} else {
				savesList.innerHTML = '<p class="saves-loading">No saves found</p>';
			}
		} catch (error) {
			savesList.innerHTML = '<p class="saves-loading">Failed to load saves</p>';
		}
	}

	async function saveGame() {
		const saveBtn = document.getElementById('menu-save-btn');
		saveBtn.disabled = true;
		saveBtn.textContent = 'Saving...';

		try {
			const response = await fetch("{% url 'api_save' %}", { method: 'POST' });
			const result = await response.json();

			if (result.status === 'saved') {
				saveBtn.textContent = 'Saved!';
				setTimeout(() => {
					saveBtn.textContent = 'Save Game';
					saveBtn.disabled = false;
				}, 2000);
				// Refresh saves list
				loadSavesList();
			} else {
				saveBtn.textContent = 'Save Failed';
				saveBtn.disabled = false;
			}
		} catch (error) {
			saveBtn.textContent = 'Save Failed';
			saveBtn.disabled = false;
		}
	}

	// ESC key handler
	document.addEventListener('keydown', function(e) {
		if (e.key === 'Escape') {
			toggleMenu();
		}
	});

	// Menu button handlers
	document.getElementById('menu-save-btn').addEventListener('click', saveGame);
	document.getElementById('menu-resume-btn').addEventListener('click', closeMenu);

	// Click outside menu to close
	document.getElementById('menu-overlay').addEventListener('click', function(e) {
		if (e.target === this) {
			closeMenu();
		}
	});

	// Initial simulation request to get things started
	if (simulationActive) {
		requestSimulation(TARGET_BUFFER);
	}
</script>
